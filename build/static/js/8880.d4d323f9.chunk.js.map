{"version":3,"file":"static/js/8880.d4d323f9.chunk.js","mappings":"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","sources":["../node_modules/@wormhole-foundation/wormhole-connect/lib/platform-BVNlkKfH.mjs","../node_modules/@wormhole-foundation/wormhole-connect/lib/chain-DZCBXrrC.mjs","../node_modules/@wormhole-foundation/wormhole-connect/lib/aptos-BpDuEuNq.mjs"],"sourcesContent":["var w = Object.defineProperty;\nvar g = (c, t, a) => t in c ? w(c, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : c[t] = a;\nvar f = (c, t, a) => g(c, typeof t != \"symbol\" ? t + \"\" : t, a);\nimport { e as u, u as m, W as C } from \"./chunk-KJH4KKG6-CP0k8JeE.mjs\";\nimport { bO as y, bP as b, W as _, n as T, m as p, bR as k, bS as N } from \"./address-CmQhtpW5.mjs\";\nimport { C as v } from \"./chain-DZCBXrrC.mjs\";\nimport { _ as I, e as l } from \"./address-BMye0hhZ.mjs\";\nclass x extends v {\n}\nconst o = class o extends y {\n  constructor(t, a) {\n    super(t, a ?? b(t, o._platform));\n  }\n  getRpc(t) {\n    if (t in this.config) {\n      const a = this.network === \"Mainnet\" ? u.MAINNET : u.TESTNET, n = new m({ fullnode: this.config[t].rpc, network: a });\n      return new C(n);\n    }\n    throw new Error(\"No configuration available for chain: \" + t);\n  }\n  getChain(t, a) {\n    if (t in this.config)\n      return new x(t, this);\n    throw new Error(\"No configuration available for chain: \" + t);\n  }\n  static nativeTokenId(t, a) {\n    if (!this.isSupportedChain(a))\n      throw new Error(`invalid chain: ${a}`);\n    return _.tokenId(a, l);\n  }\n  static isNativeTokenId(t, a, n) {\n    return !this.isSupportedChain(a) || n.chain !== a ? !1 : this.nativeTokenId(t, a) == n;\n  }\n  static isSupportedChain(t) {\n    return T(t) === o._platform;\n  }\n  static async getDecimals(t, a, n, e) {\n    if (p(e) || e === l)\n      return k(o._platform);\n    const s = e.toString();\n    return (await n.getFungibleAssetMetadataByAssetType({ assetType: s })).decimals;\n  }\n  static async getBalance(t, a, n, e, s) {\n    var r;\n    const i = p(s) ? l : s.toString();\n    try {\n      return ((r = (await n.getCurrentFungibleAssetBalances({\n        options: {\n          where: {\n            owner_address: { _eq: e },\n            asset_type: { _eq: i }\n          }\n        }\n      }))[0]) == null ? void 0 : r.amount) ?? null;\n    } catch (h) {\n      if (h.status === 404)\n        return null;\n      throw h;\n    }\n  }\n  static async getBalances(t, a, n, e) {\n    try {\n      const s = await n.getCurrentFungibleAssetBalances({\n        options: {\n          where: {\n            owner_address: { _eq: e }\n          }\n        }\n      });\n      let i = {};\n      for (const r of s)\n        if (r.asset_type) {\n          let h = r.asset_type === \"0x1::aptos_coin::AptosCoin\" ? \"native\" : r.asset_type;\n          i[h] = r.amount;\n        }\n      return i;\n    } catch (s) {\n      if (s.status === 404)\n        return {};\n      throw s;\n    }\n  }\n  static async sendWait(t, a, n) {\n    const e = [];\n    for (const s of n) {\n      const i = await a.transaction.submit.simple(s.transaction), r = await a.waitForTransaction({\n        transactionHash: i.hash\n      });\n      e.push(r.hash);\n    }\n    return e;\n  }\n  static async getLatestBlock(t) {\n    const a = await t.getLedgerInfo();\n    return Number(a.block_height);\n  }\n  static async getLatestFinalizedBlock(t) {\n    const a = await t.getLedgerInfo();\n    return Number(a.block_height);\n  }\n  static chainFromChainId(t) {\n    const a = N(o._platform, BigInt(t));\n    if (!a)\n      throw new Error(`No matching chainId to determine network and chain: ${t}`);\n    const [n, e] = a;\n    return [n, e];\n  }\n  static async chainFromRpc(t) {\n    const a = await t.getLedgerInfo();\n    return this.chainFromChainId(a.chain_id.toString());\n  }\n};\nf(o, \"_platform\", I);\nlet d = o;\nexport {\n  d as A,\n  x as a\n};\n","var g = Object.defineProperty;\nvar p = (r, t, o) => t in r ? g(r, t, { enumerable: !0, configurable: !0, writable: !0, value: o }) : r[t] = o;\nvar i = (r, t, o) => p(r, typeof t != \"symbol\" ? t + \"\" : t, o);\nimport { m as l, o as d, ck as u, t as B, cl as f, cm as k } from \"./address-CmQhtpW5.mjs\";\nclass P {\n  constructor(t, o, e) {\n    i(this, \"network\");\n    i(this, \"chain\");\n    i(this, \"config\");\n    i(this, \"platform\");\n    i(this, \"rpc\");\n    // Cached Protocol clients\n    i(this, \"protocols\", /* @__PURE__ */ new Map());\n    /**\n     * Check to see if the Wormhole Core protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Wormhole Core protocol\n     */\n    i(this, \"supportsWormholeCore\", () => this.supportsProtocol(\"WormholeCore\"));\n    /**\n     * Get the Wormhole Core protocol client for this chain\n     * @returns the Wormhole Core protocol client for this chain\n     */\n    i(this, \"getWormholeCore\", () => this.getProtocol(\"WormholeCore\"));\n    /**\n     * Check to see if the Token Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Token Bridge protocol\n     */\n    i(this, \"supportsTokenBridge\", () => this.supportsProtocol(\"TokenBridge\"));\n    /**\n     * Get the Token Bridge protocol client for this chain\n     * @returns the Token Bridge protocol client for this chain\n     */\n    i(this, \"getTokenBridge\", () => this.getProtocol(\"TokenBridge\"));\n    /**\n     * Check to see if the Automatic Token Bridge protocol is supported by this chain\n     * @returns  a boolean indicating if this chain supports the Automatic Token Bridge protocol\n     */\n    i(this, \"supportsAutomaticTokenBridge\", () => this.supportsProtocol(\"AutomaticTokenBridge\"));\n    /**\n     * Get the Automatic Token Bridge protocol client for this chain\n     * @returns the Automatic Token Bridge protocol client for this chain\n     */\n    i(this, \"getAutomaticTokenBridge\", () => this.getProtocol(\"AutomaticTokenBridge\"));\n    /**\n     * Check to see if the Executor Token Bridge protocol is supported by this chain\n     * @returns  a boolean indicating if this chain supports the Executor Token Bridge protocol\n     */\n    i(this, \"supportsExecutorTokenBridge\", () => this.supportsProtocol(\"ExecutorTokenBridge\"));\n    /**\n     * Get the Executor Token Bridge protocol client for this chain\n     * @returns the Executor Token Bridge protocol client for this chain\n     */\n    i(this, \"getExecutorTokenBridge\", () => this.getProtocol(\"ExecutorTokenBridge\"));\n    /**\n     * Check to see if the Circle Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Circle Bridge protocol\n     */\n    i(this, \"supportsCircleBridge\", () => this.supportsProtocol(\"CircleBridge\"));\n    /**\n     * Get the Circle Bridge protocol client for this chain\n     * @returns the Circle Bridge protocol client for this chain\n     */\n    i(this, \"getCircleBridge\", () => this.getProtocol(\"CircleBridge\"));\n    /**\n     * Check to see if the Automatic Circle Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Automatic Circle Bridge protocol\n     */\n    i(this, \"supportsAutomaticCircleBridge\", () => this.supportsProtocol(\"AutomaticCircleBridge\"));\n    /**\n     * Get the Automatic Circle Bridge protocol client for this chain\n     * @returns the Automatic Circle Bridge protocol client for this chain\n     */\n    i(this, \"getAutomaticCircleBridge\", () => this.getProtocol(\"AutomaticCircleBridge\"));\n    /**\n     * Check to see if the IBC Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the IBC Bridge protocol\n     */\n    i(this, \"supportsIbcBridge\", () => this.supportsProtocol(\"IbcBridge\"));\n    /**\n     * Get the IBC Bridge protocol client for this chain\n     * @returns the IBC Bridge protocol client for this chain\n     */\n    i(this, \"getIbcBridge\", () => this.getProtocol(\"IbcBridge\"));\n    /**\n     * Check to see if the Portico Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the Portico Bridge protocol\n     */\n    i(this, \"supportsPorticoBridge\", () => this.supportsProtocol(\"PorticoBridge\"));\n    /**\n     * Get the Portico Bridge protocol client for this chain\n     * @returns the Portico Bridge protocol client for this chain\n     */\n    i(this, \"getPorticoBridge\", () => this.getProtocol(\"PorticoBridge\"));\n    /**\n     * Check to see if the TBTC Bridge protocol is supported by this chain\n     * @returns a boolean indicating if this chain supports the TBTC Bridge protocol\n     */\n    i(this, \"supportsTBTCBridge\", () => this.supportsProtocol(\"TBTCBridge\"));\n    /**\n     * Get the TBTC Bridge protocol client for this chain\n     * @returns the TBTC Bridge protocol client for this chain\n     */\n    i(this, \"getTBTCBridge\", () => this.getProtocol(\"TBTCBridge\"));\n    this.config = o.config[t], this.platform = o, this.chain = this.config.key, this.network = this.config.network, this.rpc = e;\n  }\n  /**\n   * Get an RPC connection for this chain, uses the configuration passed in\n   * the initial constructor\n   *\n   * @returns the RPC connection for this chain\n   */\n  getRpc() {\n    return this.rpc = this.rpc ? this.rpc : this.platform.getRpc(this.chain), this.rpc;\n  }\n  /**\n   *  Get the number of decimals for a token\n   *\n   *  @param token the token to get the decimals for\n   *  @returns the number of decimals for the token\n   */\n  async getDecimals(t) {\n    if (l(t))\n      return this.config.nativeTokenDecimals;\n    if (this.config.tokenMap) {\n      const o = d({ chain: this.chain, address: t }), e = u(this.network, this.chain, o);\n      if (e)\n        return e.decimals;\n    }\n    return this.platform.utils().getDecimals(this.network, this.chain, await this.getRpc(), t);\n  }\n  /**\n   * Get the balance of a token for a given address\n   *\n   * @param walletAddr the address to get the balance for\n   * @param token the token to get the balance for\n   * @returns the balance of the token for the address\n   *\n   */\n  async getBalance(t, o) {\n    return this.platform.utils().getBalance(this.network, this.chain, await this.getRpc(), t, o);\n  }\n  /**\n   * Get the latest block number seen by the chain according to the RPC\n   *\n   * @returns the latest block number\n   */\n  async getLatestBlock() {\n    return this.platform.utils().getLatestBlock(await this.getRpc());\n  }\n  /**\n   * Get the latest _finalized_ block number seen by the chain according to the RPC\n   *\n   * @returns the latest finalized block number\n   */\n  async getLatestFinalizedBlock() {\n    return this.platform.utils().getLatestFinalizedBlock(await this.getRpc());\n  }\n  /**\n   * Parse the Wormhole Core messages from a transaction\n   *\n   * @param txid the transaction to parse\n   * @returns the Wormhole Core messages emitted by the transaction\n   */\n  async parseTransaction(t) {\n    return this.platform.parseWormholeMessages(this.chain, await this.getRpc(), t);\n  }\n  /**\n   *  Send a transaction and wait for it to be confirmed\n   *\n   * @param stxns the signed transaction to send\n   * @returns the transaction hashes of the sent transactions\n   */\n  async sendWait(t) {\n    return this.platform.utils().sendWait(this.chain, await this.getRpc(), t);\n  }\n  /**\n   * Get the token data from the local cache if available\n   * @param symbol the symbol of the token to get\n   * @returns the token data if available\n   */\n  getToken(t) {\n    if (this.config.tokenMap && t in this.config.tokenMap)\n      return this.config.tokenMap[t];\n  }\n  /**\n   * Get the token id of the wrapped token for the native gas token\n   *\n   * @returns the wrapped token for the native gas token\n   */\n  async getNativeWrappedTokenId() {\n    if (this.config.wrappedNative) {\n      const { address: o } = this.config.wrappedNative;\n      return { chain: this.chain, address: B(this.chain, o) };\n    }\n    const t = await this.getTokenBridge();\n    return { chain: this.chain, address: await t.getWrappedNative() };\n  }\n  /**\n   * Get the token account for a given address and token\n   *\n   * @remarks\n   * This is really only useful in the context of Solana but in order\n   * to provide a consistent interface, we provide it here.\n   *\n   * @param address the address to get the token account for\n   * @param token the token to get the token account for\n   * @returns the token account for the address and token\n   */\n  async getTokenAccount(t, o) {\n    return { chain: this.chain, address: t };\n  }\n  /**\n   * Check to see if a given protocol is supported by this chain\n   * by checking if it is registered in the platform and the configuration\n   * is available and correct\n   *\n   * @param protocolName the name of the Protocol to check for support\n   * @returns a boolean indicating if this protocol is supported\n   */\n  supportsProtocol(t) {\n    return f(this.chain, t);\n  }\n  /**\n   * Construct a protocol client for the given protocol\n   *\n   * Note: If no contracts are passed, we assume the default contracts should be used\n   * and that the protocol client is cacheable\n   *\n   * @param protocolName The name of the protocol to construct a client for\n   * @returns An instance of the protocol client that implements the protocol interface for the chain\n   */\n  async getProtocol(t, o, e) {\n    if (!o && this.protocols.has(t))\n      return this.protocols.get(t);\n    const a = o ? { ...this.config.contracts, ...o } : this.config.contracts, c = e ?? await this.getRpc(), n = this.platform.getProtocolInitializer(t);\n    let s;\n    if (e) {\n      if (o)\n        throw new Error(\"Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.\");\n      s = await this.platform.getProtocol(t, c);\n    } else if (k(n)) {\n      const h = await n.getVersion(c, a);\n      s = new n(this.network, this.chain, c, a, h);\n    } else\n      s = new n(this.network, this.chain, c, a);\n    return o || this.protocols.set(t, s), s;\n  }\n}\nexport {\n  P as C\n};\n","var d = Object.defineProperty;\nvar p = (n, t, s) => t in n ? d(n, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : n[t] = s;\nvar r = (n, t, s) => p(n, typeof t != \"symbol\" ? t + \"\" : t, s);\nimport { A as o, a as u } from \"./platform-BVNlkKfH.mjs\";\nimport { z as g, a as m } from \"./chunk-KJH4KKG6-CP0k8JeE.mjs\";\nimport { k as _, bN as f } from \"./address-CmQhtpW5.mjs\";\nimport { d as l, _ as A } from \"./address-BMye0hhZ.mjs\";\nasync function S(n, t) {\n  const [s, i] = await o.chainFromRpc(n), a = g.fromPrivateKey({\n    // TODO: support secp256k1\n    privateKey: new m(_.decode(t))\n  });\n  return new w(i, a, n);\n}\nclass w {\n  constructor(t, s, i, a) {\n    r(this, \"_chain\");\n    r(this, \"_account\");\n    r(this, \"_rpc\");\n    r(this, \"_debug\");\n    this._chain = t, this._account = s, this._rpc = i, this._debug = a;\n  }\n  chain() {\n    return this._chain;\n  }\n  address() {\n    return this._account.accountAddress.toString();\n  }\n  async signAndSend(t) {\n    const s = [];\n    for (const i of t) {\n      const { description: a, transaction: c } = i;\n      this._debug && console.log(`Signing: ${a} for ${this.address()}`);\n      const e = await this._rpc.transaction.build.simple({\n        sender: this._account.accountAddress,\n        data: c\n      }), { hash: h } = await this._simSignSend(e);\n      s.push(h);\n    }\n    return s;\n  }\n  async _simSignSend(t) {\n    return await this._rpc.transaction.simulate.simple({\n      signerPublicKey: this._account.publicKey,\n      transaction: t\n    }).then((s) => s.forEach((i) => {\n      if (!i.success)\n        throw new Error(`Transaction failed: ${i.vm_status}\n${JSON.stringify(i, null, 2)}`);\n    })), this._rpc.signAndSubmitTransaction({ signer: this._account, transaction: t }).then((s) => this._rpc.waitForTransaction({ transactionHash: s.hash }));\n  }\n}\nconst P = {\n  Address: l,\n  Platform: o,\n  getSigner: S,\n  protocols: {\n    WormholeCore: () => import(\"./index-Czy8Td_6.mjs\"),\n    TokenBridge: () => import(\"./index-kKC1ERkr.mjs\"),\n    CircleBridge: () => import(\"./index-Ln6xhy3-.mjs\")\n  },\n  getChain: (n, t, s) => new u(t, new o(n, f(n, A, {\n    [t]: s\n  })))\n};\nexport {\n  P as default\n};\n"],"names":["w","Object","defineProperty","x","v","o","y","constructor","t","a","super","b","_platform","getRpc","this","config","network","u","MAINNET","TESTNET","n","m","fullnode","rpc","C","Error","getChain","nativeTokenId","isSupportedChain","concat","_","tokenId","l","isNativeTokenId","chain","T","getDecimals","e","p","k","s","toString","getFungibleAssetMetadataByAssetType","assetType","decimals","getBalance","r","i","_ref","getCurrentFungibleAssetBalances","options","where","owner_address","_eq","asset_type","amount","h","status","getBalances","sendWait","transaction","submit","simple","waitForTransaction","transactionHash","hash","push","getLatestBlock","getLedgerInfo","Number","block_height","getLatestFinalizedBlock","chainFromChainId","N","BigInt","chainFromRpc","chain_id","f","c","I","g","enumerable","configurable","writable","value","d","P","Map","supportsProtocol","getProtocol","platform","key","nativeTokenDecimals","tokenMap","address","utils","parseTransaction","parseWormholeMessages","getToken","getNativeWrappedTokenId","wrappedNative","B","getTokenBridge","getWrappedNative","getTokenAccount","protocols","has","get","_objectSpread","contracts","getProtocolInitializer","getVersion","set","_chain","_account","_rpc","_debug","accountAddress","signAndSend","description","console","log","build","sender","data","_simSignSend","simulate","signerPublicKey","publicKey","then","forEach","success","vm_status","JSON","stringify","signAndSubmitTransaction","signer","Address","Platform","getSigner","async","fromPrivateKey","privateKey","decode","WormholeCore","TokenBridge","CircleBridge","A"],"sourceRoot":""}