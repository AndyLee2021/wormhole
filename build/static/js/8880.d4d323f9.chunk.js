"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[8880],{1238:(t,i,e)=>{e.d(i,{A:()=>p,a:()=>c});var s=e(2136),o=e(1640),r=e(6408),n=e(9292),a=Object.defineProperty;class c extends r.C{}const h=class t extends o.bO{constructor(i,e){super(i,null!==e&&void 0!==e?e:(0,o.bP)(i,t._platform))}getRpc(t){if(t in this.config){const i="Mainnet"===this.network?s.e.MAINNET:s.e.TESTNET,e=new s.u({fullnode:this.config[t].rpc,network:i});return new s.W(e)}throw new Error("No configuration available for chain: "+t)}getChain(t,i){if(t in this.config)return new c(t,this);throw new Error("No configuration available for chain: "+t)}static nativeTokenId(t,i){if(!this.isSupportedChain(i))throw new Error("invalid chain: ".concat(i));return o.W.tokenId(i,n.e)}static isNativeTokenId(t,i,e){return!(!this.isSupportedChain(i)||e.chain!==i)&&this.nativeTokenId(t,i)==e}static isSupportedChain(i){return(0,o.n)(i)===t._platform}static async getDecimals(i,e,s,r){if((0,o.m)(r)||r===n.e)return(0,o.bR)(t._platform);const a=r.toString();return(await s.getFungibleAssetMetadataByAssetType({assetType:a})).decimals}static async getBalance(t,i,e,s,r){var a;const c=(0,o.m)(r)?n.e:r.toString();try{var h;return null!==(h=null==(a=(await e.getCurrentFungibleAssetBalances({options:{where:{owner_address:{_eq:s},asset_type:{_eq:c}}}}))[0])?void 0:a.amount)&&void 0!==h?h:null}catch(l){if(404===l.status)return null;throw l}}static async getBalances(t,i,e,s){try{const t=await e.getCurrentFungibleAssetBalances({options:{where:{owner_address:{_eq:s}}}});let i={};for(const e of t)if(e.asset_type){i["0x1::aptos_coin::AptosCoin"===e.asset_type?"native":e.asset_type]=e.amount}return i}catch(o){if(404===o.status)return{};throw o}}static async sendWait(t,i,e){const s=[];for(const o of e){const t=await i.transaction.submit.simple(o.transaction),e=await i.waitForTransaction({transactionHash:t.hash});s.push(e.hash)}return s}static async getLatestBlock(t){const i=await t.getLedgerInfo();return Number(i.block_height)}static async getLatestFinalizedBlock(t){const i=await t.getLedgerInfo();return Number(i.block_height)}static chainFromChainId(i){const e=(0,o.bS)(t._platform,BigInt(i));if(!e)throw new Error("No matching chainId to determine network and chain: ".concat(i));const[s,r]=e;return[s,r]}static async chainFromRpc(t){const i=await t.getLedgerInfo();return this.chainFromChainId(i.chain_id.toString())}};var l,g,u;l=h,g="_platform",u=n._,((t,i,e)=>{i in t?a(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e})(l,"symbol"!=typeof g?g+"":g,u);let p=h},6408:(t,i,e)=>{e.d(i,{C:()=>a});var s=e(9379),o=e(1640),r=Object.defineProperty,n=(t,i,e)=>((t,i,e)=>i in t?r(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e)(t,"symbol"!=typeof i?i+"":i,e);class a{constructor(t,i,e){n(this,"network"),n(this,"chain"),n(this,"config"),n(this,"platform"),n(this,"rpc"),n(this,"protocols",new Map),n(this,"supportsWormholeCore",()=>this.supportsProtocol("WormholeCore")),n(this,"getWormholeCore",()=>this.getProtocol("WormholeCore")),n(this,"supportsTokenBridge",()=>this.supportsProtocol("TokenBridge")),n(this,"getTokenBridge",()=>this.getProtocol("TokenBridge")),n(this,"supportsAutomaticTokenBridge",()=>this.supportsProtocol("AutomaticTokenBridge")),n(this,"getAutomaticTokenBridge",()=>this.getProtocol("AutomaticTokenBridge")),n(this,"supportsExecutorTokenBridge",()=>this.supportsProtocol("ExecutorTokenBridge")),n(this,"getExecutorTokenBridge",()=>this.getProtocol("ExecutorTokenBridge")),n(this,"supportsCircleBridge",()=>this.supportsProtocol("CircleBridge")),n(this,"getCircleBridge",()=>this.getProtocol("CircleBridge")),n(this,"supportsAutomaticCircleBridge",()=>this.supportsProtocol("AutomaticCircleBridge")),n(this,"getAutomaticCircleBridge",()=>this.getProtocol("AutomaticCircleBridge")),n(this,"supportsIbcBridge",()=>this.supportsProtocol("IbcBridge")),n(this,"getIbcBridge",()=>this.getProtocol("IbcBridge")),n(this,"supportsPorticoBridge",()=>this.supportsProtocol("PorticoBridge")),n(this,"getPorticoBridge",()=>this.getProtocol("PorticoBridge")),n(this,"supportsTBTCBridge",()=>this.supportsProtocol("TBTCBridge")),n(this,"getTBTCBridge",()=>this.getProtocol("TBTCBridge")),this.config=i.config[t],this.platform=i,this.chain=this.config.key,this.network=this.config.network,this.rpc=e}getRpc(){return this.rpc=this.rpc?this.rpc:this.platform.getRpc(this.chain),this.rpc}async getDecimals(t){if((0,o.m)(t))return this.config.nativeTokenDecimals;if(this.config.tokenMap){const i=(0,o.o)({chain:this.chain,address:t}),e=(0,o.ck)(this.network,this.chain,i);if(e)return e.decimals}return this.platform.utils().getDecimals(this.network,this.chain,await this.getRpc(),t)}async getBalance(t,i){return this.platform.utils().getBalance(this.network,this.chain,await this.getRpc(),t,i)}async getLatestBlock(){return this.platform.utils().getLatestBlock(await this.getRpc())}async getLatestFinalizedBlock(){return this.platform.utils().getLatestFinalizedBlock(await this.getRpc())}async parseTransaction(t){return this.platform.parseWormholeMessages(this.chain,await this.getRpc(),t)}async sendWait(t){return this.platform.utils().sendWait(this.chain,await this.getRpc(),t)}getToken(t){if(this.config.tokenMap&&t in this.config.tokenMap)return this.config.tokenMap[t]}async getNativeWrappedTokenId(){if(this.config.wrappedNative){const{address:t}=this.config.wrappedNative;return{chain:this.chain,address:(0,o.t)(this.chain,t)}}const t=await this.getTokenBridge();return{chain:this.chain,address:await t.getWrappedNative()}}async getTokenAccount(t,i){return{chain:this.chain,address:t}}supportsProtocol(t){return(0,o.cl)(this.chain,t)}async getProtocol(t,i,e){if(!i&&this.protocols.has(t))return this.protocols.get(t);const r=i?(0,s.A)((0,s.A)({},this.config.contracts),i):this.config.contracts,n=null!==e&&void 0!==e?e:await this.getRpc(),a=this.platform.getProtocolInitializer(t);let c;if(e){if(i)throw new Error("Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.");c=await this.platform.getProtocol(t,n)}else if((0,o.cm)(a)){const t=await a.getVersion(n,r);c=new a(this.network,this.chain,n,r,t)}else c=new a(this.network,this.chain,n,r);return i||this.protocols.set(t,c),c}}},8880:(t,i,e)=>{e.r(i),e.d(i,{default:()=>l});var s=e(1238),o=e(2136),r=e(1640),n=e(9292),a=Object.defineProperty,c=(t,i,e)=>((t,i,e)=>i in t?a(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e)(t,"symbol"!=typeof i?i+"":i,e);class h{constructor(t,i,e,s){c(this,"_chain"),c(this,"_account"),c(this,"_rpc"),c(this,"_debug"),this._chain=t,this._account=i,this._rpc=e,this._debug=s}chain(){return this._chain}address(){return this._account.accountAddress.toString()}async signAndSend(t){const i=[];for(const e of t){const{description:t,transaction:s}=e;this._debug&&console.log("Signing: ".concat(t," for ").concat(this.address()));const o=await this._rpc.transaction.build.simple({sender:this._account.accountAddress,data:s}),{hash:r}=await this._simSignSend(o);i.push(r)}return i}async _simSignSend(t){return await this._rpc.transaction.simulate.simple({signerPublicKey:this._account.publicKey,transaction:t}).then(t=>t.forEach(t=>{if(!t.success)throw new Error("Transaction failed: ".concat(t.vm_status,"\n").concat(JSON.stringify(t,null,2)))})),this._rpc.signAndSubmitTransaction({signer:this._account,transaction:t}).then(t=>this._rpc.waitForTransaction({transactionHash:t.hash}))}}const l={Address:n.d,Platform:s.A,getSigner:async function(t,i){const[e,n]=await s.A.chainFromRpc(t),a=o.z.fromPrivateKey({privateKey:new o.a(r.k.decode(i))});return new h(n,a,t)},protocols:{WormholeCore:()=>e.e(6552).then(e.bind(e,6552)),TokenBridge:()=>e.e(9939).then(e.bind(e,9939)),CircleBridge:()=>e.e(1302).then(e.bind(e,1302))},getChain:(t,i,e)=>new s.a(i,new s.A(t,(0,r.bN)(t,n._,{[i]:e})))}}}]);
//# sourceMappingURL=8880.d4d323f9.chunk.js.map