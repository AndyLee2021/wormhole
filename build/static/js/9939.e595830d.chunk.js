"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[9939],{2126:(e,t,n)=>{n.d(t,{A:()=>a});var s=Object.defineProperty,r=(e,t,n)=>((e,t,n)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);class a{constructor(e,t,n,s){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];r(this,"transaction"),r(this,"network"),r(this,"chain"),r(this,"description"),r(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=n,this.description=s,this.parallelizable=a}}},9939:(e,t,n)=>{n.r(t),n.d(t,{AptosTokenBridge:()=>g});var s=n(9379),r=n(6218),a=n(600),i=n(1640),o=n(9292),d=n(1238),c=n(2126),h=Object.defineProperty,u=(e,t,n)=>((e,t,n)=>t in e?h(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);const l=[(0,s.A)({name:"tokenBridgeAddress"},i.ar),(0,s.A)({name:"chain"},(0,i.at)()),{name:"domainSeparator",binary:"bytes",custom:i.f.encode(o.f),omit:!0},(0,s.A)({name:"tokenId"},i.ar),{name:"domainSeparator",binary:"bytes",custom:new Uint8Array([255]),omit:!0}];class g{constructor(e,t,n,s){u(this,"network"),u(this,"chain"),u(this,"connection"),u(this,"contracts"),u(this,"chainId"),u(this,"tokenBridgeAddress"),this.network=e,this.chain=t,this.connection=n,this.contracts=s,this.chainId=(0,i.ax)(t);const r=s.tokenBridge;if(!r)throw new Error("TokenBridge contract Address for chain ".concat(t," not found"));this.tokenBridgeAddress=r}static async fromRpc(e,t){const[n,s]=await d.A.chainFromRpc(e),r=t[s];if(r.network!==n)throw new Error("Network mismatch "+r.network+" !== "+n);return new g(n,s,e,r.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch(t){return!1}}async getOriginalAsset(e){const t=e.toString().split(o.f),n=await this.connection.getAccountResource({accountAddress:t[0],resourceType:"".concat(this.tokenBridgeAddress,"::state::OriginInfo")});if(!n)throw(0,i.dm)(e.toString());return{chain:(0,i.ad)(parseInt(n.token_chain.number)),address:new i.U(n.token_address.external_address)}}async getTokenUniversalAddress(e){return new i.U(i.k.encode((0,i.cJ)(e.toString()),!0))}async getTokenNativeAddress(e,t){const n=e===this.chain?await this.getTypeFromExternalAddress(t.toString()):await this.getAssetFullyQualifiedType({chain:e,address:t});if(!n)throw new Error("Invalid asset address.");return new o.d(n)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch(t){}return!1}async getWrappedAsset(e){if((0,i.m)(e.address))throw new Error("native asset cannot be a wrapped asset");const t=await this.getAssetFullyQualifiedType(e);if(!t)throw new Error("Invalid asset address.");return await this.connection.getAccountResource({accountAddress:(0,o.g)(t),resourceType:"".concat(this.tokenBridgeAddress,"::state::OriginInfo")}),(0,i.t)(this.chain,t)}async isTransferCompleted(e){const t=(await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:"".concat(this.tokenBridgeAddress,"::state::State")})).consumed_vaas.elems.handle;try{return await this.connection.getTableItem({handle:t,data:{key_type:"vector<u8>",value_type:"u8",key:"0x".concat(i.d.Buffer.from((0,i.aw)(e.hash)).toString("hex"))}}),!0}catch(n){return!1}}async getWrappedNative(){return(0,i.t)(this.chain,o.e)}createAttestation(e,t){var n=this;return(0,a.A)(function*(){const t={chain:n.chain,address:new o.d(e)},s=yield(0,r.A)(n.getAssetFullyQualifiedType(t));if(!s)throw new Error("Invalid asset address.");yield n.createUnsignedTx({function:"".concat(n.tokenBridgeAddress,"::attest_token::attest_token_entry"),typeArguments:[s],functionArguments:[]},"Aptos.AttestToken")})()}submitAttestation(e,t){var n=this;return(0,a.A)(function*(){yield n.createUnsignedTx({function:"".concat(n.tokenBridgeAddress,"::wrapped::create_wrapped_coin_type"),typeArguments:[],functionArguments:[(0,i.aE)(e)]},"Aptos.CreateWrappedCoinType");const t=yield(0,r.A)(n.getAssetFullyQualifiedType(e.payload.token));if(!t)throw new Error("Invalid asset address.");yield n.createUnsignedTx({function:"".concat(n.tokenBridgeAddress,"::wrapped::create_wrapped_coin"),typeArguments:[t],functionArguments:[(0,i.aE)(e)]},"Aptos.CreateWrappedCoin")})()}transfer(e,t,n,s,r){var d=this;return(0,a.A)(function*(){const e=(0,i.m)(n)?o.e:n.toString(),a=t.address.toUniversalAddress().toUint8Array(),c=(0,i.ax)(t.chain);r?yield d.createUnsignedTx({function:"".concat(d.tokenBridgeAddress,"::transfer_tokens::transfer_tokens_with_payload_entry"),typeArguments:[e],functionArguments:[s,c,a,0n,r]},"Aptos.TransferTokensWithPayload"):yield d.createUnsignedTx({function:"".concat(d.tokenBridgeAddress,"::transfer_tokens::transfer_tokens_entry"),typeArguments:[e],functionArguments:[s,c,a,0n,0n]},"Aptos.TransferTokens")})()}redeem(e,t){var n=this;return(0,a.A)(function(e,t){return function*(){const e=t.payload.token.chain===n.chain?yield(0,r.A)(n.getTypeFromExternalAddress(t.payload.token.address.toString())):yield(0,r.A)(n.getAssetFullyQualifiedType(t.payload.token));if(!e)throw new Error("Invalid asset address.");yield n.createUnsignedTx({function:"".concat(n.tokenBridgeAddress,"::complete_transfer::submit_vaa_and_register_entry"),typeArguments:[e],functionArguments:[(0,i.aE)(t)]},"Aptos.CompleteTransfer")}()}).apply(this,arguments)}async getAssetFullyQualifiedType(e){return e.chain===this.chain?(0,o.i)(e.address.toString())?e.address.toString():null:"".concat(g.getForeignAssetAddress(this.chain,this.tokenBridgeAddress,e),"::coin::T")}async getTypeFromExternalAddress(e){try{const t=await this.connection.getAccountResource({accountAddress:this.tokenBridgeAddress,resourceType:"".concat(this.tokenBridgeAddress,"::state::State")}),{handle:n}=t.native_infos,s=await this.connection.getTableItem({handle:n,data:{key_type:"".concat(this.tokenBridgeAddress,"::token_hash::TokenHash"),value_type:"0x1::type_info::TypeInfo",key:{hash:e}}});return s?[s.account_address,String.fromCharCode(...i.k.decode(s.module_name)),String.fromCharCode(...i.k.decode(s.struct_name))].join(o.f):null}catch(t){return null}}static getForeignAssetAddress(e,t,n){if((0,i.m)(n.address))throw new Error("Invalid token address");const s=(r={chain:n.chain,tokenBridgeAddress:new o.d(t).toUniversalAddress(),tokenId:n.address.toUniversalAddress()},(0,i.av)(l,r));var r;return i.k.encode((0,i.cJ)(s),!0)}createUnsignedTx(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new c.A(e,this.network,this.chain,t,n)}}(0,i.aF)("Aptos","TokenBridge",g)}}]);
//# sourceMappingURL=9939.e595830d.chunk.js.map