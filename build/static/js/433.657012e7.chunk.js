"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[433],{433:(t,e,i)=>{i.d(e,{a:()=>k,d:()=>y,g:()=>g});var o=i(1640),n=i(8338),r=Object.defineProperty,s=(t,e,i)=>((t,e,i)=>e in t?r(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i)(t,"symbol"!=typeof e?e+"":e,i);const a=.5,c=1,l=1,h=1e8,u=5;async function g(t,e,i){var r,s,a;const[c,l]=await n.a.chainFromRpc(t),h="string"==typeof e?o.a0.fromSecretKey(o.cg.decode(e)):e;if(null!=i&&i.priorityFee&&i.priorityFee.percentile&&i.priorityFee.percentile>1)throw new Error("priorityFeePercentile must be a number between 0 and 1");return new d(t,l,h,null!==(r=null==i?void 0:i.debug)&&void 0!==r&&r,null!==(s=null==i?void 0:i.priorityFee)&&void 0!==s?s:{},null!==(a=null==i?void 0:i.retries)&&void 0!==a?a:u,null==i?void 0:i.sendOpts)}class d{constructor(t,e,i){var o;let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:u,c=arguments.length>6?arguments[6]:void 0;s(this,"_rpc"),s(this,"_chain"),s(this,"_keypair"),s(this,"_debug"),s(this,"_priorityFee"),s(this,"_maxResubmits"),s(this,"_sendOpts"),this._rpc=t,this._chain=e,this._keypair=i,this._debug=n,this._priorityFee=r,this._maxResubmits=a,this._sendOpts=c,this._sendOpts=null!==(o=this._sendOpts)&&void 0!==o?o:{preflightCommitment:this._rpc.commitment}}chain(){return this._chain}address(){return this._keypair.publicKey.toBase58()}retryable(t){var e;if(t instanceof o.ch)return!0;if(!(t instanceof o.ci)||!t.message.includes("Transaction simulation failed"))return!1;if(t.message.includes("Blockhash not found"))return!0;const i=null==(e=t.logs)?void 0:e.find(t=>t.startsWith("Program log: Error: "));return!!i&&!(!i.includes("Not enough bytes")&&!i.includes("Unexpected length of input"))}async signAndSend(t){var e;let{blockhash:i,lastValidBlockHeight:r}=await n.a.latestBlock(this._rpc);const s=[];for(const l of t){const{description:t,transaction:{transaction:a,signers:h}}=l;let u;this._debug&&console.log("Signing: ".concat(t," for ").concat(this.address())),null!=(e=this._priorityFee)&&e.percentile&&this._priorityFee.percentile>0&&(u=await m(this._rpc,a,this._priorityFee.percentile,this._priorityFee.percentileMultiple,this._priorityFee.min,this._priorityFee.max)),this._debug&&p(a);for(let e=0;e<this._maxResubmits;e++)try{if((0,n.i)(a)){if(u&&0===e){const t=o.aI.decompile(a.message);t.instructions.push(...u),a.message=t.compileToV0Message()}a.message.recentBlockhash=i,a.sign([this._keypair,...null!==h&&void 0!==h?h:[]])}else u&&0===e&&a.add(...u),a.recentBlockhash=i,a.lastValidBlockHeight=r,a.partialSign(this._keypair,...null!==h&&void 0!==h?h:[]);this._debug&&console.log("Submitting transactions ");const{signature:t}=await n.a.sendTxWithRetry(this._rpc,a.serialize(),this._sendOpts);s.push(t);break}catch(c){if(e===this._maxResubmits-1||!this.retryable(c))throw c;this._debug&&console.log("Failed to send transaction on attempt ".concat(e,", retrying: "),c);const{blockhash:t,lastValidBlockHeight:o}=await n.a.latestBlock(this._rpc);r=o,i=t}}this._debug&&console.log("Waiting for confirmation for: ",s);const a=(await Promise.all(s.map(async t=>{try{return await this._rpc.confirmTransaction({signature:t,blockhash:i,lastValidBlockHeight:r},this._rpc.commitment)}catch(e){throw console.error("Failed to confirm transaction: ",e),e}}))).filter(t=>t.value.err).map(t=>t.value.err);if(a.length>0)throw new Error("Failed to confirm transaction: ".concat(a));return s}}function p(t){if((0,n.i)(t)){console.log(t.signatures);const e=t.message,i=e.getAccountKeys();e.compiledInstructions.forEach(t=>{console.log("Program",i.get(t.programIdIndex).toBase58()),console.log("Data: ",o.k.encode(t.data)),console.log("Keys: ",t.accountKeyIndexes.map(t=>[t,i.get(t).toBase58()]))})}else console.log(t.signatures),console.log(t.feePayer),t.instructions.forEach(t=>{console.log("Program",t.programId.toBase58()),console.log("Data: ",t.data.toString("hex")),console.log("Keys: ",t.keys.map(t=>[t,t.pubkey.toBase58()]))})}async function m(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:a,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:l,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:h;const[u,g]=await Promise.all([f(t,e),k(t,e,i,n,r,s)]);return[o._.setComputeUnitLimit({units:u}),o._.setComputeUnitPrice({microLamports:g})]}async function f(t,e){var i;let o=25e4;try{const r=await((0,n.i)(e),t.simulateTransaction(e));r.value.err&&console.error("Error simulating Solana transaction: ".concat(r.value.err)),null!=(i=null==r?void 0:r.value)&&i.unitsConsumed&&(o=Math.round(1.2*r.value.unitsConsumed))}catch(r){console.error("Failed to calculate compute unit limit for Solana transaction: ".concat(r))}return o}async function w(t,e){if((0,n.i)(e)){const i=(await Promise.all(e.message.addressTableLookups.map(e=>t.getAddressLookupTable(e.accountKey)))).map(t=>t.value).filter(t=>null!==t),o=e.message,n=o.getAccountKeys({addressLookupTableAccounts:null!==i&&void 0!==i?i:void 0});return o.compiledInstructions.flatMap(t=>t.accountKeyIndexes).map(t=>o.isAccountWritable(t)?n.get(t):null).filter(Boolean)}return e.instructions.flatMap(t=>t.keys).map(t=>t.isWritable?t.pubkey:null).filter(Boolean)}async function k(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:a,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:l,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:h,s=n;const u=await w(t,e);try{const e=await t.getRecentPrioritizationFees({lockedWritableAccounts:u});if(e){const t=e.map(t=>t.prioritizationFee).sort((t,e)=>t-e),n=Math.ceil(t.length*i);if(t.length>n){let e=t[n];o>0&&(e*=o),s=Math.max(s,e)}}}catch(g){console.error("Error fetching Solana recent fees",g)}return Math.min(Math.max(s,n),r)}async function y(t,e){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:l,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:h;const s=1e4*(arguments.length>2&&void 0!==arguments[2]?arguments[2]:a);if(s<1||s>1e4)throw new Error("percentile must be between 0.0001 and 1");const u=t._rpcRequest,g=[await w(t,e),{percentile:s}],d=await u("getRecentPrioritizationFees",g);if(d.error)throw new Error(d.error);const p=d.result.map(t=>t.prioritizationFee);if(0===p.length)return n;const m=Math.floor((0,o.ce)(p)*(i>0?i:1));return(0,o.cf)(m,n,r)}},6408:(t,e,i)=>{i.d(e,{C:()=>a});var o=i(9379),n=i(1640),r=Object.defineProperty,s=(t,e,i)=>((t,e,i)=>e in t?r(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i)(t,"symbol"!=typeof e?e+"":e,i);class a{constructor(t,e,i){s(this,"network"),s(this,"chain"),s(this,"config"),s(this,"platform"),s(this,"rpc"),s(this,"protocols",new Map),s(this,"supportsWormholeCore",()=>this.supportsProtocol("WormholeCore")),s(this,"getWormholeCore",()=>this.getProtocol("WormholeCore")),s(this,"supportsTokenBridge",()=>this.supportsProtocol("TokenBridge")),s(this,"getTokenBridge",()=>this.getProtocol("TokenBridge")),s(this,"supportsAutomaticTokenBridge",()=>this.supportsProtocol("AutomaticTokenBridge")),s(this,"getAutomaticTokenBridge",()=>this.getProtocol("AutomaticTokenBridge")),s(this,"supportsExecutorTokenBridge",()=>this.supportsProtocol("ExecutorTokenBridge")),s(this,"getExecutorTokenBridge",()=>this.getProtocol("ExecutorTokenBridge")),s(this,"supportsCircleBridge",()=>this.supportsProtocol("CircleBridge")),s(this,"getCircleBridge",()=>this.getProtocol("CircleBridge")),s(this,"supportsAutomaticCircleBridge",()=>this.supportsProtocol("AutomaticCircleBridge")),s(this,"getAutomaticCircleBridge",()=>this.getProtocol("AutomaticCircleBridge")),s(this,"supportsIbcBridge",()=>this.supportsProtocol("IbcBridge")),s(this,"getIbcBridge",()=>this.getProtocol("IbcBridge")),s(this,"supportsPorticoBridge",()=>this.supportsProtocol("PorticoBridge")),s(this,"getPorticoBridge",()=>this.getProtocol("PorticoBridge")),s(this,"supportsTBTCBridge",()=>this.supportsProtocol("TBTCBridge")),s(this,"getTBTCBridge",()=>this.getProtocol("TBTCBridge")),this.config=e.config[t],this.platform=e,this.chain=this.config.key,this.network=this.config.network,this.rpc=i}getRpc(){return this.rpc=this.rpc?this.rpc:this.platform.getRpc(this.chain),this.rpc}async getDecimals(t){if((0,n.m)(t))return this.config.nativeTokenDecimals;if(this.config.tokenMap){const e=(0,n.o)({chain:this.chain,address:t}),i=(0,n.ck)(this.network,this.chain,e);if(i)return i.decimals}return this.platform.utils().getDecimals(this.network,this.chain,await this.getRpc(),t)}async getBalance(t,e){return this.platform.utils().getBalance(this.network,this.chain,await this.getRpc(),t,e)}async getLatestBlock(){return this.platform.utils().getLatestBlock(await this.getRpc())}async getLatestFinalizedBlock(){return this.platform.utils().getLatestFinalizedBlock(await this.getRpc())}async parseTransaction(t){return this.platform.parseWormholeMessages(this.chain,await this.getRpc(),t)}async sendWait(t){return this.platform.utils().sendWait(this.chain,await this.getRpc(),t)}getToken(t){if(this.config.tokenMap&&t in this.config.tokenMap)return this.config.tokenMap[t]}async getNativeWrappedTokenId(){if(this.config.wrappedNative){const{address:t}=this.config.wrappedNative;return{chain:this.chain,address:(0,n.t)(this.chain,t)}}const t=await this.getTokenBridge();return{chain:this.chain,address:await t.getWrappedNative()}}async getTokenAccount(t,e){return{chain:this.chain,address:t}}supportsProtocol(t){return(0,n.cl)(this.chain,t)}async getProtocol(t,e,i){if(!e&&this.protocols.has(t))return this.protocols.get(t);const r=e?(0,o.A)((0,o.A)({},this.config.contracts),e):this.config.contracts,s=null!==i&&void 0!==i?i:await this.getRpc(),a=this.platform.getProtocolInitializer(t);let c;if(i){if(e)throw new Error("Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.");c=await this.platform.getProtocol(t,s)}else if((0,n.cm)(a)){const t=await a.getVersion(s,r);c=new a(this.network,this.chain,s,r,t)}else c=new a(this.network,this.chain,s,r);return e||this.protocols.set(t,c),c}}},8338:(t,e,i)=>{i.d(e,{A:()=>u,S:()=>p,T:()=>l,a:()=>d,b:()=>c,i:()=>m});var o=i(9379),n=i(1640),r=i(6408),s=Object.defineProperty,a=(t,e,i)=>((t,e,i)=>e in t?s(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i)(t,"symbol"!=typeof e?e+"":e,i);class c extends r.C{async getTokenAccount(t,e){const{getAssociatedTokenAddress:o}=await i.e(3400).then(i.bind(i,3400)),r=new n.aM(e).unwrap(),s=new n.aM(t).unwrap(),a=await o(r,s);return{chain:this.chain,address:new n.aM(a.toString())}}}const l=new n.P("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),h=new n.P("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),u=new n.P("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new n.P("So11111111111111111111111111111111111111112"),new n.P("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");const g=class t extends n.bO{constructor(e,i){super(e,null!==i&&void 0!==i?i:(0,n.bP)(e,t._platform))}getRpc(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{commitment:"confirmed",disableRetryOnRateLimit:!0};if(t in this.config)return new n.H(this.config[t].rpc,e);throw new Error("No configuration available for chain: "+t)}getChain(t,e){if(t in this.config)return new c(t,this,e);throw new Error("No configuration available for chain: "+t)}static nativeTokenId(e,i){if(!t.isSupportedChain(i))throw new Error("invalid chain: ".concat(i));return n.W.chainAddress(i,n.cj)}static isNativeTokenId(t,e,i){return!(!this.isSupportedChain(e)||i.chain!==e)&&this.nativeTokenId(t,e)==i}static isSupportedChain(e){return(0,n.n)(e)===t._platform}static async getDecimals(e,i,o,r){if((0,n.m)(r))return(0,n.bR)(t._platform);let s=await o.getParsedAccountInfo(new n.aM(r).unwrap());if(!s||!s.value)throw new Error("could not fetch token details");const{decimals:a}=s.value.data.parsed.info;return a}static async getBalance(t,e,i,o,r){const s=new n.P(o);if((0,n.m)(r))return BigInt(await i.getBalance(s));const a=await i.getTokenAccountsByOwner(s,{mint:new n.aM(r).unwrap()}),c=a.value.length>0?a.value[0].pubkey:s,l=await i.getTokenAccountBalance(c);return BigInt(l.value.amount)}static async getBalances(t,e,i,o){const r=BigInt(await i.getBalance(new n.P(o))),s=(await Promise.all([l,h].map(t=>new n.P(t)).map(t=>i.getParsedTokenAccountsByOwner(new n.P(o),{programId:t})))).reduce((t,e)=>t.concat(e.value),[]),a={native:r};return s.forEach(t=>{var e,i,o,n,r;const s=null==(i=null==(e=t.account.data.parsed)?void 0:e.info)?void 0:i.mint,c=null==(r=null==(n=null==(o=t.account.data.parsed)?void 0:o.info)?void 0:n.tokenAmount)?void 0:r.amount;s&&c&&(a[s]=BigInt(c))}),a}static async sendWait(t,e,i,o){const n=await Promise.all(i.map(t=>this.sendTxWithRetry(e,t,o))),r=n.map(t=>t.signature),s=n.filter(t=>t.response.value.err).map(t=>t.response.value.err);if(s.length>0)throw new Error("Failed to confirm transaction: ".concat(s));return r}static async sendTxWithRetry(t,e){var i;let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:5e3;const s=null!==(i=n.preflightCommitment)&&void 0!==i?i:t.commitment,a=await t.sendRawTransaction(e,(0,o.A)((0,o.A)({},n),{},{skipPreflight:!1,maxRetries:0,preflightCommitment:s})),{blockhash:c,lastValidBlockHeight:l}=await t.getLatestBlockhash(),h=t.confirmTransaction({signature:a,blockhash:c,lastValidBlockHeight:l},s);let u=null;for(;!u&&(u=await Promise.race([h,new Promise(t=>setTimeout(()=>{t(null)},r))]),!u);)await t.sendRawTransaction(e,(0,o.A)((0,o.A)({},n),{},{skipPreflight:!0,maxRetries:0,preflightCommitment:s}));return{signature:a,response:u}}static async latestBlock(t,e){return t.getLatestBlockhash(null!==e&&void 0!==e?e:t.commitment)}static async getLatestBlock(t){return await t.getSlot()}static async getLatestFinalizedBlock(t){const{lastValidBlockHeight:e}=await this.latestBlock(t,"finalized");return e}static chainFromChainId(e){const i=(0,n.bS)(t._platform,e);if(!i)throw new Error("No matching genesis hash to determine network and chain: ".concat(e));const[o,r]=i;return[o,r]}static async chainFromRpc(e){try{const i=await e.getGenesisHash();return t.chainFromChainId(i)}catch(i){if(e.rpcEndpoint.includes("http://127")||e.rpcEndpoint.includes("http://localhost")||"http://solana-devnet:8899"===e.rpcEndpoint)return["Devnet","Solana"];throw i}}static async getTokenProgramId(t,e){const i=await t.getAccountInfo(e);if(!i)throw new Error("Mint account not found: ".concat(e.toBase58()));const o=i.owner;if(!o)throw new Error("Mint account has no owner: ".concat(e.toBase58()));if(o.equals(l)||o.equals(h))return o;throw new Error("Mint account has unsupported token program: ".concat(e.toBase58()," (").concat(o.toBase58(),")"))}};a(g,"_platform",n.aO);let d=g;class p{constructor(t,e,i,o){let n=arguments.length>4&&void 0!==arguments[4]&&arguments[4];a(this,"transaction"),a(this,"network"),a(this,"chain"),a(this,"description"),a(this,"parallelizable"),this.transaction=t,this.network=e,this.chain=i,this.description=o,this.parallelizable=n}}function m(t){return void 0!==t.signatures&&void 0!==t.message}}}]);
//# sourceMappingURL=433.657012e7.chunk.js.map