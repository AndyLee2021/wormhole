"use strict";(self.webpackChunkbrige_typescript=self.webpackChunkbrige_typescript||[]).push([[3671,6286],{1394:(e,t,r)=>{r.d(t,{S:()=>a});var n=Object.defineProperty,o=(e,t,r)=>((e,t,r)=>t in e?n(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class a{constructor(e,t,r,n){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];o(this,"transaction"),o(this,"network"),o(this,"chain"),o(this,"description"),o(this,"parallelizable"),this.transaction=e,this.network=t,this.chain=r,this.description=n,this.parallelizable=a}}},3671:(e,t,r)=>{r.r(t),r.d(t,{SuiWormholeCore:()=>l});var n=r(600),o=r(1640),a=r(9480),i=r(7605),s=r(4408),c=Object.defineProperty,d=(e,t,r)=>((e,t,r)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class l{constructor(e,t,r,n){d(this,"network"),d(this,"chain"),d(this,"provider"),d(this,"contracts"),d(this,"chainId"),d(this,"coreBridgePackageId"),this.network=e,this.chain=t,this.provider=r,this.contracts=n,this.chainId=(0,o.ax)(t);const a=n.coreBridge;if(!a)throw new Error("CoreBridge contract Address for chain ".concat(t," not found"));this.coreBridgePackageId=a}getGuardianSet(e){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[r,n]=await a.w.chainFromRpc(e),o=t[n];if(o.network!==r)throw new Error("Network mismatch: ".concat(o.network," !== ").concat(r));return new l(r,n,e,o.contracts)}verifyMessage(e,t){return(0,n.A)(function*(){throw new Error("Method not implemented.")})()}publishMessage(e,t){return(0,n.A)(function*(){throw new Error("Method not implemented.")})()}async parseTransaction(e){return(await this.parseMessages(e)).map(e=>({emitter:e.emitterAddress,sequence:e.sequence,chain:this.chain}))}async getGuardianSetIndex(){throw new Error("Method not implemented.")}async parseMessages(e){var t;const r=null==(t=(await this.provider.getTransactionBlock({digest:e,options:{showEvents:!0,showEffects:!0,showInput:!0}})).events)?void 0:t.filter(e=>e.type.endsWith("WormholeMessage"));if(!r||0==r.length)throw new Error("WormholeMessage not found");return r.map(e=>{const t=e.parsedJson;return(0,i.c)("Uint8Array",{emitterChain:this.chain,emitterAddress:new s.S(t.sender).toUniversalAddress(),sequence:BigInt(t.sequence),guardianSet:0,timestamp:Number(t.timestamp),consistencyLevel:t.consistency_level,nonce:t.nonce,signatures:[],payload:new Uint8Array(t.payload)})})}}(0,o.aF)("Sui","WormholeCore",l)},6286:(e,t,r)=>{r.r(t),r.d(t,{SuiAutomaticTokenBridge:()=>p,SuiTokenBridge:()=>h,getTokenCoinType:()=>g,getTokenFromTokenRegistry:()=>u});var n=r(6218),o=r(600),a=r(9480),i=r(4408),s=(r(3671),r(1640)),c=r(1394),d=Object.defineProperty,l=(e,t,r)=>((e,t,r)=>t in e?d(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);const u=async(e,t,r)=>{var n,o,s;if(!(0,i.i)(r))throw new Error("Invalid Sui type: ".concat(r));const c=await(0,a.A)(e,t);if(!c)throw new Error("Unable to fetch object fields from token bridge state. Object ID: ".concat(t));const d=null==(o=null==(n=c.token_registry.fields)?void 0:n.id)?void 0:o.id;if(!d)throw new Error("Unable to fetch token registry object ID");const l=(0,i.o)(null==(s=c.token_registry)?void 0:s.type);if(!l)throw new Error("Unable to fetch token registry package ID");return e.getDynamicFieldObject({parentId:d,name:{type:"".concat(l,"::token_registry::Key<").concat(r,">"),value:{dummy_field:!1}}})},g=async(e,t,r,n)=>{var o,s,c,d;const l=await(0,a.A)(e,t);if(!l)throw new Error("Unable to fetch object fields from token bridge state");const u=null==(s=null==(o=l.token_registry)?void 0:o.fields)?void 0:s.coin_types,g=null==(d=null==(c=null==u?void 0:u.fields)?void 0:c.id)?void 0:d.id;if(!g)throw new Error("Unable to fetch coin types");const h=(0,i.q)(null==u?void 0:u.type);if(!h)throw new Error("Unable to get key type");const p=await e.getDynamicFieldObject({parentId:g,name:{type:h,value:{addr:[...r],chain:n}}});if(p.error){if("dynamicFieldNotFound"===p.error.code)return null;throw new Error("Unexpected getDynamicFieldObject response ".concat(p.error))}const f=(0,a.B)(p);if(!f)return null;if(!(0,a.C)(f))throw new Error("What?");return"value"in f?(0,i.r)(f.value):null};class h{constructor(e,t,r,n){l(this,"network"),l(this,"chain"),l(this,"provider"),l(this,"contracts"),l(this,"coreBridgeObjectId"),l(this,"tokenBridgeObjectId"),l(this,"chainId"),this.network=e,this.chain=t,this.provider=r,this.contracts=n,this.chainId=s.y.get(e,t);const o=this.contracts.tokenBridge;if(!o)throw new Error("Wormhole Token Bridge contract for domain ".concat(t," not found"));const a=this.contracts.coreBridge;if(!a)throw new Error("Wormhole Token Bridge contract for domain ".concat(t," not found"));this.tokenBridgeObjectId=o,this.coreBridgeObjectId=a}static async fromRpc(e,t){const[r,n]=await a.w.chainFromRpc(e),o=t[n];if(o.network!==r)throw new Error("Network mismatch: ".concat(o.network," != ").concat(r));return new h(r,n,e,o.contracts)}async isWrappedAsset(e){try{return await this.getOriginalAsset(e),!0}catch(t){return!1}}async getOriginalAsset(e){let t=e.getCoinType();if(!(0,i.i)(t))throw new Error("Invalid Sui type: ".concat(t));const r=await u(this.provider,this.tokenBridgeObjectId,t),n=(0,a.B)(r);if(!n)throw(0,s.dm)(t);if(!(0,a.C)(n))throw new Error("Expected fields to be a MoveStruct");if(!("value"in n))throw new Error("Expected a `value` key in fields of MoveStruct");const o=n.value;if(!(0,a.D)(o))throw new Error("Expected fields to be a MoveStruct");const c=(0,i.r)(o.type);if(t=(0,i.r)(t),c.includes("wrapped_asset::WrappedAsset<".concat(t,">"))){const e=o.fields.info;if(!(0,a.D)(e))throw new Error("Expected fields to be a MoveStruct");const t=e.fields.token_address;if(!(0,a.D)(t))throw new Error("Expected fields to be a MoveStruct");if(!(0,a.C)(t.fields))throw new Error("Expected address data to be a MoveObject");if(!("value"in t.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const r=t.fields.value;if(!(0,a.D)(r))throw new Error("Expected fields to be a MoveStruct");const n=new Uint8Array(r.fields.data);return{chain:(0,s.ad)(Number(e.fields.token_chain)),address:new s.U(n)}}throw(0,s.dm)(t)}async getTokenUniversalAddress(e){let t=e.getCoinType();if(!(0,i.i)(t))throw new Error("Invalid Sui type: ".concat(t));const r=await u(this.provider,this.tokenBridgeObjectId,t),n=(0,a.B)(r);if(!n)throw new Error("Token of type ".concat(t," has not been registered with the token bridge. Has it been attested?"));if(!(0,a.C)(n))throw new Error("Expected fields to be a MoveStruct");if(!("value"in n))throw new Error("Expected a `value` key in fields of MoveStruct");const o=n.value;if(!(0,a.D)(o))throw new Error("Expected fields to be a MoveStruct");const c=(0,i.r)(o.type);if(t=(0,i.r)(t),c.includes("native_asset::NativeAsset<".concat(t,">"))){const e=o.fields.token_address;if(!(0,a.D)(e))throw new Error("Expected fields to be a MoveStruct");if(!("value"in e.fields))throw new Error("Expected a `value` key in fields of MoveStruct");const t=e.fields.value;if(!(0,a.D)(t))throw new Error("Expected fields to be a MoveStruct");const r=new Uint8Array(t.fields.data);return new s.U(r)}throw new Error("Token of type ".concat(t," is not a native asset"))}async getTokenNativeAddress(e,t){const r=await g(this.provider,this.tokenBridgeObjectId,t.toUint8Array(),(0,s.ax)(e));if(!r)throw new Error("Token ".concat(t.toString()," not found in token registry"));return new i.S(r)}async hasWrappedAsset(e){try{return await this.getWrappedAsset(e),!0}catch(t){}return!1}async getWrappedAsset(e){if((0,s.m)(e.address))throw new Error("Token Address required, 'native' literal not supported");const t=await g(this.provider,this.tokenBridgeObjectId,e.address.toUniversalAddress().toUint8Array(),(0,s.ax)(e.chain));if(!t)throw(0,s.dm)((0,s.o)(e));return(0,s.t)(this.chain,t)}async isTransferCompleted(e){var t,r,n,o,c,d,l,u;const g=await(0,a.A)(this.provider,this.tokenBridgeObjectId);if(!g)throw new Error("Unable to fetch object fields from token bridge state");const h=null==(r=null==(t=g.consumed_vaas)?void 0:t.fields)?void 0:r.hashes,p=(0,i.q)(null==(o=null==(n=null==h?void 0:h.fields)?void 0:n.items)?void 0:o.type);if(!p)throw new Error("Unable to get key type");const f=null==(u=null==(l=null==(d=null==(c=null==h?void 0:h.fields)?void 0:c.items)?void 0:d.fields)?void 0:l.id)?void 0:u.id;if(!f)throw new Error("Unable to fetch consumed VAAs table");const w=await this.provider.getDynamicFieldObject({parentId:f,name:{type:p,value:{data:[...(0,s.aw)(e.hash)]}}});if(!w.error)return!0;if("dynamicFieldNotFound"===w.error.code)return!1;throw new Error("Unexpected getDynamicFieldObject response ".concat(w.error))}createAttestation(e){var t=this;return(0,o.A)(function*(){const r=e.toString(),o=yield(0,n.A)(t.provider.getCoinMetadata({coinType:r}));if(null===o||null===o.id)throw new Error("Coin metadata ID for type ".concat(r," not found"));const[i,s]=yield(0,n.A)(t.getPackageIds()),c=new a.T,[d]=c.splitCoins(c.gas,[c.pure.u64(0n)]),[l]=c.moveCall({target:"".concat(s,"::attest_token::attest_token"),arguments:[c.object(t.tokenBridgeObjectId),c.object(o.id),c.pure.u32(0)],typeArguments:[r]});c.moveCall({target:"".concat(i,"::publish_message::publish_message"),arguments:[c.object(t.coreBridgeObjectId),d,l,c.object(a.v)]}),yield t.createUnsignedTx(c,"Sui.TokenBridge.CreateAttestation")})()}submitAttestation(e,t){var r=this;return(0,o.A)(function*(){const[o,c]=yield(0,n.A)(r.getPackageIds()),d=t.toString(),l=Math.min(e.payload.decimals,8),u=yield(0,n.A)(r.getCoinBuildOutput(o,c,l)),g=yield(0,n.A)((0,a.E)(u,d));yield r.createUnsignedTx(g,"Sui.TokenBridge.PrepareCreateWrapped");let h="",p="",f="",w="",y="",m=!1;for(;!m;){yield(0,n.A)(new Promise(e=>setTimeout(e,500)));const e=yield(0,n.A)(r.provider.queryTransactionBlocks({filter:{FromAddress:d},options:{showObjectChanges:!0},limit:3}));for(const t of e.data)if("objectChanges"in t){for(const e of t.objectChanges)(0,a.F)(e)&&void 0!==e.packageId?h=e.packageId:(0,a.G)(e)&&e.objectType.includes("WrappedAssetSetup")?(p=e.objectId,y=e.objectType.split(", ")[1].replace(">","")):(0,a.G)(e)&&e.objectType.includes("UpgradeCap")?f=e.objectId:(0,a.G)(e)&&e.objectType.includes("CoinMetadata")&&(w=e.objectId);if(""!==h&&""!==p&&""!==f&&""!==w){m=!0;break}h="",p="",f="",w=""}}const b=(0,i.u)(h),v=new a.T,[k]=v.moveCall({target:"".concat(o,"::vaa::parse_and_verify"),arguments:[v.object(r.coreBridgeObjectId),v.pure.vector("u8",(0,s.aE)(e)),v.object(a.v)]}),[j]=v.moveCall({target:"".concat(c,"::vaa::verify_only_once"),arguments:[v.object(r.tokenBridgeObjectId),k]});v.moveCall({target:"".concat(c,"::create_wrapped::complete_registration"),arguments:[v.object(r.tokenBridgeObjectId),v.object(w),v.object(p),v.object(f),j],typeArguments:[b,y]}),yield r.createUnsignedTx(v,"Sui.TokenBridge.SubmitAttestation")})()}transfer(e,t,r,i,c){var d=this;return(0,o.A)(function*(){const o=e.toString(),l=((0,s.m)(r)?a.S:r).toString(),u=yield(0,n.A)(a.w.getCoins(d.provider,e,l)),[g,...h]=u.filter(e=>(0,a.H)(e.coinType,l));if(void 0===g)throw new Error("Coins array doesn't contain any coins of type ".concat(l));const[p,f]=yield(0,n.A)(d.getPackageIds()),w=new a.T,[y]=(()=>{if(l===a.S)return w.splitCoins(w.gas,[w.pure.u64(i)]);{const e=w.object(g.coinObjectId);return h.length&&w.mergeCoins(e,h.map(e=>w.object(e.coinObjectId))),w.splitCoins(e,[w.pure.u64(i)])}})(),[m]=w.splitCoins(w.gas,[w.pure.u64(0n)]),[b]=w.moveCall({target:"".concat(f,"::state::verified_asset"),arguments:[w.object(d.tokenBridgeObjectId)],typeArguments:[l]});if(c){if(!o)throw new Error("senderAddress is required for transfer with payload");let e=!1;const r=yield(0,n.A)((async()=>{const t=await(0,a.I)(d.provider,p,o);if(null!==t)return w.object(t);{const[t]=w.moveCall({target:"".concat(p,"::emitter::new"),arguments:[w.object(d.coreBridgeObjectId)]});return e=!0,t}})()),[i,u]=w.moveCall({target:"".concat(f,"::transfer_tokens_with_payload::prepare_transfer"),arguments:[r,b,y,w.pure.u16((0,s.ax)(t.chain)),w.pure.vector("u8",t.address.toUint8Array()),w.pure.vector("u8",c),w.pure.u32(0)],typeArguments:[l]});w.moveCall({target:"".concat(f,"::coin_utils::return_nonzero"),arguments:[u],typeArguments:[l]});const[g]=w.moveCall({target:"".concat(f,"::transfer_tokens_with_payload::transfer_tokens_with_payload"),arguments:[w.object(d.tokenBridgeObjectId),i],typeArguments:[l]});w.moveCall({target:"".concat(p,"::publish_message::publish_message"),arguments:[w.object(d.coreBridgeObjectId),m,g,w.object(a.v)]}),e&&w.transferObjects([r],w.pure.address(o)),yield d.createUnsignedTx(w,"Sui.TokenBridge.TransferWithPayload")}else{const[e,r]=w.moveCall({target:"".concat(f,"::transfer_tokens::prepare_transfer"),arguments:[b,y,w.pure.u16((0,s.ax)(t.chain)),w.pure.vector("u8",t.address.toUint8Array()),w.pure.u64(0n),w.pure.u32(0)],typeArguments:[l]});w.moveCall({target:"".concat(f,"::coin_utils::return_nonzero"),arguments:[r],typeArguments:[l]});const[n]=w.moveCall({target:"".concat(f,"::transfer_tokens::transfer_tokens"),arguments:[w.object(d.tokenBridgeObjectId),e],typeArguments:[l]});w.moveCall({target:"".concat(p,"::publish_message::publish_message"),arguments:[w.object(d.coreBridgeObjectId),m,n,w.object(a.v)]}),yield d.createUnsignedTx(w,"Sui.TokenBridge.Transfer")}})()}redeem(e,t){var r=this;return(0,o.A)(function(e,t){return function*(){const e=yield(0,n.A)(g(r.provider,r.tokenBridgeObjectId,t.payload.token.address.toUint8Array(),(0,s.ax)(t.payload.token.chain)));if(!e)throw new Error("Unable to fetch token coinType");const[o,i]=yield(0,n.A)(r.getPackageIds()),c=new a.T,[d]=c.moveCall({target:"".concat(o,"::vaa::parse_and_verify"),arguments:[c.object(r.coreBridgeObjectId),c.pure.vector("u8",(0,s.aE)(t)),c.object(a.v)]}),[l]=c.moveCall({target:"".concat(i,"::vaa::verify_only_once"),arguments:[c.object(r.tokenBridgeObjectId),d]}),[u]=c.moveCall({target:"".concat(i,"::complete_transfer::authorize_transfer"),arguments:[c.object(r.tokenBridgeObjectId),l],typeArguments:[e]}),[h]=c.moveCall({target:"".concat(i,"::complete_transfer::redeem_relayer_payout"),arguments:[u],typeArguments:[e]});c.moveCall({target:"".concat(i,"::coin_utils::return_nonzero"),arguments:[h],typeArguments:[e]}),yield r.createUnsignedTx(c,"Sui.TokenBridge.Redeem")}()}).apply(this,arguments)}async getWrappedNative(){return(0,s.t)(this.chain,a.S)}async getPackageIds(){return Promise.all([(0,a.J)(this.provider,this.coreBridgeObjectId),(0,a.J)(this.provider,this.tokenBridgeObjectId)])}async getCoinBuildOutput(e,t,r){var n;if(r>8)throw new Error("Decimals is capped at 8");const o=null==(n=await(0,a.K)(this.provider,this.tokenBridgeObjectId))?void 0:n.replace("0x","");if(!o)throw new Error("Original token bridge package ID not found for object ID ".concat(this.tokenBridgeObjectId));const c="a11ceb0b060000000901000a020a14031e1704350405392d07669f01088502600ae502050cea02160004010b010c0205020d000002000201020003030c020001000104020700000700010001090801010c020a050600030803040202000302010702080007080100020800080303090002070801010b020209000901010608010105010b0202080008030209000504434f494e095478436f6e7465787408565f5f305f325f3011577261707065644173736574536574757004636f696e0e6372656174655f777261707065640b64756d6d795f6669656c6404696e697414707265706172655f726567697374726174696f6e0f7075626c69635f7472616e736665720673656e646572087472616e736665720a74785f636f6e746578740f76657273696f6e5f636f6e74726f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"+o+"00020106010000000001090b0031"+r.toString(16).padStart(2,"0")+"0a0138000b012e110238010200";return{modules:[s.l.encode(s.k.decode(c))],dependencies:["0x1","0x2",t,e].map(e=>(0,i.k)(e))}}createUnsignedTx(e,t){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new c.S(e,this.network,this.chain,t,r)}}class p{constructor(e,t,r,n){l(this,"network"),l(this,"chain"),l(this,"connection"),l(this,"contracts"),l(this,"tokenBridgeRelayerObjectId"),l(this,"coreBridgeObjectId"),l(this,"tokenBridgeObjectId"),l(this,"fields"),this.network=e,this.chain=t,this.connection=r,this.contracts=n;const{tokenBridge:o,tokenBridgeRelayer:a,coreBridge:i}=n;if(!o||!a||!i)throw new Error("Some object IDs for ".concat(t," Automatic Token Bridge not found"));this.tokenBridgeRelayerObjectId=a,this.tokenBridgeObjectId=o,this.coreBridgeObjectId=i}static async fromRpc(e,t){const[r,n]=await a.w.chainFromRpc(e),o=t[n];if(o.network!==r)throw new Error("Network mismatch for chain ".concat(n,": ").concat(o.network," != ").concat(r));return new p(r,n,e,o.contracts)}transfer(e,t,r,c,d){var l=this;return(0,o.A)(function*(){const o=new i.S((0,s.m)(r)?a.w.nativeTokenId(l.network,l.chain).address:r).getCoinType(),{coreBridge:u,tokenBridge:g}=yield(0,n.A)(l.getPackageIds()),h=new a.T,p=BigInt(0),[f]=h.splitCoins(h.gas,[h.pure.u64(p)]),[w]=yield(0,n.A)((async()=>{if((0,s.m)(r))return h.splitCoins(h.gas,[h.pure.u64(c)]);{const t=await a.w.getCoins(l.connection,e,o),[r,...n]=t.filter(e=>e.coinType===o);if(void 0===r)throw new Error("Coins array doesn't contain any coins of type ".concat(o));const i=h.object(r.coinObjectId);return n.length&&h.mergeCoins(i,n.map(e=>h.object(e.coinObjectId))),h.splitCoins(i,[h.pure.u64(c)])}})()),[y]=h.moveCall({target:"".concat(g,"::state::verified_asset"),arguments:[h.object(l.tokenBridgeObjectId)],typeArguments:[o]}),m=yield(0,n.A)(l.getPackageId()),[b]=h.moveCall({target:"".concat(m,"::transfer::transfer_tokens_with_relay"),arguments:[h.object(l.tokenBridgeRelayerObjectId),w,y,h.pure.u64(null!==d&&void 0!==d?d:0n),h.pure.u16((0,s.ax)(t.chain)),h.pure.address(s.k.encode(t.address.toUint8Array(),!0)),h.pure.u32(123)],typeArguments:[o]}),[v]=h.moveCall({target:"".concat(g,"::transfer_tokens_with_payload::transfer_tokens_with_payload"),arguments:[h.object(l.tokenBridgeObjectId),b],typeArguments:[o]});h.moveCall({target:"".concat(u,"::publish_message::publish_message"),arguments:[h.object(l.coreBridgeObjectId),f,v,h.object(a.v)]}),yield l.createUnsignedTx(h,"AutomaticTokenBridge.transfer")})()}redeem(e,t){var r=this;return(0,o.A)(function*(){const{coreBridge:e,tokenBridge:o}=yield(0,n.A)(r.getPackageIds()),{address:i,chain:c}=t.payload.token,d=yield(0,n.A)(g(r.connection,r.tokenBridgeObjectId,i.toUniversalAddress().toUint8Array(),(0,s.ax)(c)));if(!d)throw new Error("Unable to fetch token coinType");const l=new a.T,[u]=l.moveCall({target:"".concat(e,"::vaa::parse_and_verify"),arguments:[l.object(r.coreBridgeObjectId),l.pure.vector("u8",(0,s.aE)(t)),l.object(a.v)]}),[h]=l.moveCall({target:"".concat(o,"::vaa::verify_only_once"),arguments:[l.object(r.tokenBridgeObjectId),u]}),[p]=l.moveCall({target:"".concat(o,"::complete_transfer_with_payload::authorize_transfer"),arguments:[l.object(r.tokenBridgeObjectId),h],typeArguments:[d]}),f=yield(0,n.A)(r.getPackageId());l.moveCall({target:"".concat(f,"::redeem::complete_transfer"),arguments:[l.object(r.tokenBridgeRelayerObjectId),p],typeArguments:[d]}),yield r.createUnsignedTx(l,"AutomaticTokenBridge.redeem")})()}async getRelayerFee(e,t){const r=(0,s.m)(t)?a.w.nativeTokenId(this.network,this.chain):t,n=await this.getTokenInfo(r.toString());if(null===n)throw new Error("Unsupported token for relay");const o=await this.getFields(),i=await this.connection.getDynamicFieldObject({parentId:this.tokenBridgeRelayerObjectId,name:{type:"vector<u8>",value:Array.from(s.f.encode("relayer_fees"))}});if(!i.data||!i.data.content)throw i.error?new Error("Failed to get relayer fees: "+JSON.stringify(i.error)):new Error("Unable to compute relayer fee");const{content:c}=i.data;if(!(0,a.D)(c)||!(0,a.L)(c.fields.id))throw new Error("Unable to compute relayer fee");const d=await this.connection.getDynamicFieldObject({parentId:c.fields.id.id,name:{type:"u16",value:(0,s.ax)(e)}});if(!d.data||!d.data.content)throw d.error?new Error("Failed to get relayer fees: "+JSON.stringify(i.error)):new Error("Unable to compute relayer fee");const{content:l}=d.data;if(!(0,a.D)(l))throw new Error("Unable to compute relayer fee");const u=await a.w.getDecimals(this.network,this.chain,this.connection,t.toString()),g=n.swap_rate,h=o.relayer_fee_precision,p=o.swap_rate_precision,f=l.fields.value;return 10n**BigInt(u)*BigInt(f)*BigInt(p)/(BigInt(g)*BigInt(h))}async maxSwapAmount(e){var t,r;const n=((0,s.m)(e)?a.w.nativeTokenId(this.network,this.chain):e).toString(),o=await this.connection.getCoinMetadata({coinType:n});if(!o)throw new Error("metadata is null");const i=await this.getPackageId(),c=new a.T;c.moveCall({target:"".concat(i,"::redeem::calculate_max_swap_amount_in"),arguments:[c.object(this.tokenBridgeRelayerObjectId),c.pure.u8(o.decimals)],typeArguments:[n]});const d=await this.connection.devInspectTransactionBlock({transactionBlock:c,sender:s.k.encode(new Uint8Array(32))});if(!d.results||0==d.results.length||null==(t=d.results[0])||!t.returnValues||1!==(null==(r=d.results[0])?void 0:r.returnValues.length))throw Error("swap rate not set");return s.h.decode(new Uint8Array(d.results[0].returnValues[0][0].toReversed()))}async nativeTokenAmount(e,t){var r,n;const o=((0,s.m)(e)?a.w.nativeTokenId(this.network,this.chain):e).toString(),i=await this.connection.getCoinMetadata({coinType:o});if(!i)throw new Error("metadata is null");const c=await this.getPackageId(),d=new a.T;d.moveCall({target:"".concat(c,"::redeem::calculate_native_swap_amount_out"),arguments:[d.object(this.tokenBridgeRelayerObjectId),d.pure.u64(t),d.pure.u8(i.decimals)],typeArguments:[o]});const l=await this.connection.devInspectTransactionBlock({transactionBlock:d,sender:s.k.encode(new Uint8Array(32))});if(!l.results||0==l.results.length||null==(r=l.results[0])||!r.returnValues||1!==(null==(n=l.results[0])?void 0:n.returnValues.length))throw Error("swap rate not set");return s.h.decode(new Uint8Array(l.results[0].returnValues[0][0].toReversed()))}async getRegisteredTokens(){const e=(await this.getFields()).registered_tokens.fields.id.id;return(await this.connection.getDynamicFields({parentId:e})).data.map(e=>{const{address:t,module:r,name:n}=(0,i.v)(e.objectType);return new i.S([t,r,n].join(i.w))})}async isRegisteredToken(e){const t=new i.S((0,s.m)(e)?a.w.nativeTokenId(this.network,this.chain).address:e).unwrap();try{return null!==await this.getTokenInfo(t)}catch(r){console.error(r)}return!1}async getTokenInfo(e){var t;const r=await this.getFields(),n=new i.S(r.registered_tokens.type).getPackageId(),o=r.registered_tokens.fields.id.id,s=new i.S(e),c=(0,a.H)(i.p,s.unwrap())?i.p:s.getCoinType();try{const e=await this.connection.getDynamicFieldObject({parentId:o,name:{type:"".concat(n,"::registered_tokens::Key<").concat(c,">"),value:{dummy_field:!1}}});if(e.error)throw new Error("Failed to get token info: "+JSON.stringify(e.error));if(!e.data||!e.data.content)throw new Error("Failed to get token info: "+JSON.stringify(e));const{content:t}=e.data;return(0,a.D)(t)&&(0,a.D)(t.fields.value)?t.fields.value.fields:null}catch(d){if(-32e3===(null==d?void 0:d.code)&&null!=(t=d.message)&&t.includes("RPC Error"))return console.error(d),null;throw d}}async getFields(){if(!this.fields){const e=await(0,a.A)(this.connection,this.tokenBridgeRelayerObjectId);if(null===e)throw new Error("Failed to get fields from token bridge relayer state");this.fields=e}return this.fields}async getPackageId(){const e=await this.getFields();return new i.S(e.registered_tokens.type).getPackageId()}async getPackageIds(){const[e,t]=await Promise.all([(0,a.J)(this.connection,this.coreBridgeObjectId),(0,a.J)(this.connection,this.tokenBridgeObjectId)]);return{coreBridge:e,tokenBridge:t}}createUnsignedTx(e,t){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new c.S(e,this.network,this.chain,t,r)}}(0,s.aF)("Sui","TokenBridge",h),(0,s.aF)("Sui","AutomaticTokenBridge",p)},7605:(e,t,r)=>{r.d(t,{c:()=>i});var n=r(9379),o=r(1640);function a(e){return[...o.dB,(0,o.dC)(e)]}function i(e,t){const[r,i]=(0,o.dz)(e),s=(0,o.dA)(a(e),t);return(0,n.A)((0,n.A)((0,n.A)({protocolName:r,payloadName:i,payloadLiteral:e},(0,o.dA)(o.dD,t)),s),{},{hash:(0,o.aw)((0,o.av)(a(e),s))})}}}]);
//# sourceMappingURL=6286.1a5671ba.chunk.js.map